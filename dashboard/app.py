from flask import Flask, render_template, jsonify, request
import mysql.connector
import traceback
from functools import wraps

app = Flask(__name__)

# ---------------------------------------------------
# Database Connection
# ---------------------------------------------------
def get_db_connection():
    return mysql.connector.connect(
        host="localhost",
        user="root",
        password="sit123",  # change if needed
        database="bookmyshow"
    )

# Decorator to fetch connection info safely (used internally)
def with_db_connection(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        conn = get_db_connection()
        try:
            return f(conn, *args, **kwargs)
        finally:
            conn.close()
    return decorated_function

# ---------------------------------------------------
# Function Metadata (for UI hints)
# ---------------------------------------------------
FUNCTION_METADATA = {
    "getAvailableSeats": {
        "description": "Returns the number of available seats for a given show ID.",
        "params": ["show_id"]
    },
    "getBookingTotal": {
        "description": "Returns the total amount paid for a booking.",
        "params": ["booking_id"]
    },
    "getMovieRating": {
        "description": "Fetches the rating for a specific movie.",
        "params": ["movie_id"]
    },
    "getMovieRevenue": {
        "description": "Returns total revenue generated by a movie.",
        "params": ["movie_id"]
    },
    "getPaymentStatus": {
        "description": "Checks payment status for a booking.",
        "params": ["booking_id"]
    },
    "getTheaterLocation": {
        "description": "Returns location of a theater.",
        "params": ["theater_id"]
    },
    "getTotalEarningsByTheater": {
        "description": "Calculates total earnings of a specific theater.",
        "params": ["theater_id"]
    },
    "getUpcomingShows": {
        "description": "Lists shows scheduled after a given date.",
        "params": ["theater_id"]
    },
}

# ---------------------------------------------------
# Procedure Metadata (for UI hints)
# ---------------------------------------------------
PROCEDURE_METADATA = {
    "Get_Upcoming_Shows_By_Movie": "Fetches all upcoming shows for a specific movie.",
    "Get_Booking_Details_By_User": "Shows complete booking history for a user.",
    "Get_Revenue_By_Theater": "Summarizes total revenue generated per theater.",
    "Get_Show_Occupancy": "Displays occupancy percentage for each show.",
    "Get_Monthly_Revenue_Report": "Generates current year's monthly revenue report.",
    "ShowPerformanceSummary": "Calculates the occupancy rate for a specific show ID (uses OUT parameter)." # NEW
}

# ---------------------------------------------------
# Homepage (Unified Dashboard)
# ---------------------------------------------------
@app.route('/')
def home():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        cursor.execute("SELECT DISTINCT genre FROM movies")
        genres = [row[0] for row in cursor.fetchall()]

        cursor.execute("SELECT DISTINCT language FROM movies")
        languages = [row[0] for row in cursor.fetchall()]

        # --- UNIFIED OPERATIONS FETCH ---
        operations = []
        # Get Functions
        cursor.execute("SHOW FUNCTION STATUS WHERE Db = 'bookmyshow'")
        operations.extend([row[1] for row in cursor.fetchall()])

        # Get Procedures
        cursor.execute("SHOW PROCEDURE STATUS WHERE Db = 'bookmyshow'")
        operations.extend([row[1] for row in cursor.fetchall()])
        # --- END UNIFIED OPERATIONS FETCH ---

        cursor.execute("SELECT table_name FROM information_schema.tables WHERE table_schema = 'bookmyshow' AND table_type = 'VIEW' ORDER BY table_name")
        views = [row[0] for row in cursor.fetchall()]

        conn.close()

        options = {
            "genres": genres,
            "languages": languages,
            "operations": operations, # Unified list of Functions and Procedures
            "views": views
        }
        return render_template("index.html", options=options)
    except Exception as e:
        print("❌ Error loading homepage:", e)
        traceback.print_exc()
        return "Database connection failed.", 500


# ---------------------------------------------------
# API: Fetch movies (Unchanged)
# ---------------------------------------------------
@app.route("/api/movies", methods=["POST"])
def get_movies():
    try:
        data = request.json
        genre = data.get("genre", "")
        language = data.get("language", "")
        search = data.get("search", "")
        sort = data.get("sort", "Latest Releases")
        page = int(data.get("page", 1))
        limit = 50
        offset = (page - 1) * limit

        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)

        query = "SELECT movie_id, title, genre, language, rating, DATE_FORMAT(release_date, '%Y-%m-%d') as release_date FROM movies WHERE 1=1"
        params = []

        if genre and genre != "All":
            query += " AND genre = %s"
            params.append(genre)
        if language and language != "All":
            query += " AND language = %s"
            params.append(language)
        if search:
            query += " AND title LIKE %s"
            params.append(f"%{search}%")

        if sort == "Latest Releases":
            query += " ORDER BY release_date DESC"
        elif sort == "Top Rated":
            query += " ORDER BY rating DESC"
        else:
            query += " ORDER BY title ASC"

        query += f" LIMIT {limit} OFFSET {offset}"

        cursor.execute(query, params)
        movies = cursor.fetchall()
        conn.close()
        return jsonify({"movies": movies, "total": len(movies)})

    except Exception as e:
        print("❌ Error fetching movies:", e)
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500


# ---------------------------------------------------
# API: Unified Operation Info (Function or Procedure)
# ---------------------------------------------------
@app.route('/api/operation_info/<op_name>')
def get_operation_info(op_name):
    """Checks if op_name is a Function or Procedure and returns its metadata, including OUT parameters for procedures."""
    
    # 1. Check if it's a known FUNCTION
    if op_name in FUNCTION_METADATA:
        info = FUNCTION_METADATA[op_name]
        info['type'] = 'FUNCTION'
        # Functions only have IN parameters implicitly
        return jsonify(info)
    
    # 2. Check if it's a PROCEDURE
    try:
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        
        # 2a. Check if procedure exists
        cursor.execute("SHOW PROCEDURE STATUS WHERE Name = %s AND Db = 'bookmyshow'", (op_name,))
        exists = cursor.fetchone()
        
        if exists:
            # 2b. Get all parameters for the procedure (IN and OUT)
            cursor.execute("""
                SELECT PARAMETER_NAME, DATA_TYPE, PARAMETER_MODE
                FROM INFORMATION_SCHEMA.PARAMETERS
                WHERE SPECIFIC_NAME = %s AND SPECIFIC_SCHEMA = 'bookmyshow'
                ORDER BY ORDINAL_POSITION
            """, (op_name,))
            all_params = cursor.fetchall()
            conn.close()
            
            # Separate IN and OUT parameters
            in_params = [p for p in all_params if p['PARAMETER_MODE'] == 'IN']
            out_params = [p for p in all_params if p['PARAMETER_MODE'] == 'OUT']
            
            description = PROCEDURE_METADATA.get(op_name, f"Custom Report: {op_name}")
            
            # UI only needs IN parameter names for input fields
            in_param_names = [p['PARAMETER_NAME'] for p in in_params]
            
            return jsonify({
                "type": "PROCEDURE",
                "description": description, 
                "params": in_param_names, # Only IN params for user input
                "out_params": [p['PARAMETER_NAME'] for p in out_params], # Used by execute_operation
                "input_types": {p['PARAMETER_NAME']: p['DATA_TYPE'] for p in in_params}
            })
            
        conn.close()
        return jsonify({"error": f"Operation '{op_name}' not found."}), 404
        
    except Exception as e:
        print("❌ Error fetching operation info:", e)
        return jsonify({"error": str(e)}), 500


# ---------------------------------------------------
# API: Unified Execute Operation (Function or Procedure)
# ---------------------------------------------------
@app.route('/api/execute_operation', methods=['POST'])
@with_db_connection
def execute_operation(conn):
    try:
        data = request.json
        op_name = data.get('operation')
        op_type = data.get('type')
        args = data.get('args', [])

        placeholders = ', '.join(['%s'] * len(args))

        if op_type == 'FUNCTION':
            # Execute as Function: SELECT function_name(...) -> Scalar result
            cursor = conn.cursor() 
            query = f"SELECT {op_name}({placeholders})" if placeholders else f"SELECT {op_name}()"
            cursor.execute(query, args)
            result = cursor.fetchone()
            return jsonify({"type": "FUNCTION", "result": result[0] if result else "No result returned"})

        elif op_type == 'PROCEDURE':
            # Get procedure info again to check for OUT params
            info_res = get_operation_info(op_name)
            info = info_res.get_json()
            out_params = info.get('out_params', [])
            
            if out_params:
                # 1. Handle Procedures with OUT parameters (like a Function)
                
                # 1a. Prepare placeholders for the CALL statement: IN args + OUT session variables
                call_args = args
                out_vars_str = ', '.join([f"@{p}" for p in out_params])
                
                in_placeholders = ', '.join(['%s'] * len(args))
                call_placeholders = (in_placeholders + ', ' if in_placeholders else '') + out_vars_str
                    
                call_query = f"CALL {op_name}({call_placeholders})"

                # 1b. Execute CALL (non-dictionary cursor is sufficient here)
                cursor = conn.cursor()
                cursor.execute(call_query, call_args)

                # 1c. Consume any result sets (e.g., if the procedure contains a SELECT before the OUT param is set)
                # It's vital to call nextset until it returns None.
                while cursor.nextset():
                    pass 
                    
                # 1d. Execute SELECT to fetch the final OUT variables' values
                select_out_query = f"SELECT {out_vars_str}"
                cursor.execute(select_out_query)
                out_values = cursor.fetchone()
                
                # For a single OUT param, return the scalar value
                if len(out_params) == 1:
                    return jsonify({"type": "FUNCTION", "result": out_values[0]})
                else:
                    # For multiple OUT params, return as a dictionary
                    result_dict = dict(zip(out_params, out_values))
                    return jsonify({"type": "FUNCTION", "result": result_dict})
                
            else:
                # 2. Handle Procedures without OUT parameters (Tabular Result)
                cursor = conn.cursor(dictionary=True) 
                query = f"CALL {op_name}({placeholders})" if placeholders else f"CALL {op_name}()"
                cursor.execute(query, args)
                result = cursor.fetchall()

                while cursor.nextset():
                    pass
                    
                return jsonify({"type": "PROCEDURE", "result": result}) 

        else:
            return jsonify({"error": "Invalid operation type provided."}), 400

    except Exception as e:
        print(f"❌ Error executing MySQL {op_type} '{op_name}':", e)
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500


# ---------------------------------------------------
# API: Execute View (Unchanged)
# ---------------------------------------------------
@app.route('/api/execute_view', methods=['POST'])
@with_db_connection
def execute_view(conn):
    try:
        data = request.json
        view_name = data.get('view')

        cursor = conn.cursor()
        query = f"SELECT * FROM `{view_name}`"
        cursor.execute(query)

        data = cursor.fetchall()
        headers = [i[0] for i in cursor.description]

        return jsonify({"headers": headers, "data": data})
    except Exception as e:
        print(f"❌ Error executing View '{view_name}':", e)
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500


# ---------------------------------------------------
# Health Check (Unchanged)
# ---------------------------------------------------
@app.route('/health')
def health():
    return "Backend is running successfully! ✅"


if __name__ == '__main__':
    app.run(debug=True)
